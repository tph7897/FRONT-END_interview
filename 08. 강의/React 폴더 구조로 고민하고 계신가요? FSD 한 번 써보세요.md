# [아직도 React 폴더 구조로 고민하고 계신가요? FSD 한 번 써보세요[제로초뉴스]](https://youtu.be/64Fx5Y1gEOA?si=Y3H923z84EBtuFOR)

# 프로젝트 폴더 구조와 FSD(Folder Slice Design) 아키텍처 소개

프론트엔드 개발을 하다 보면, 프로젝트를 시작할 때 폴더 구조를 어떻게 구성할지 고민하는 경우가 많습니다. 이 강의에서는 폴더 구조의 다양한 예시와 함께 FSD(Folder Slice Design) 아키텍처를 소개하며, 이를 통해 폴더 구조를 더 합리적으로 관리하는 방법을 설명합니다.

---

## 1. 폴더 구조에 대한 고민

개발자들이 프로젝트를 시작할 때마다 폴더 구조를 새로 정리해야 한다는 점에서 고민이 많습니다. 프로젝트마다 요구사항이 다르기 때문에, 기존에 잘 맞았던 폴더 구조가 새로운 프로젝트에는 맞지 않을 수 있습니다. 저도 프로젝트를 할 때마다 폴더 구조를 다르게 설정하고, 좋은 점을 최대한 가져오고 단점을 피하려고 노력하지만, 일관된 기준을 찾는 것이 어렵습니다.

---

## 2. 기존 폴더 구조의 문제점

일반적으로 프론트엔드 프로젝트에서는 다음과 같은 방식으로 폴더를 구성합니다:

- **컴포넌트 폴더**: 화면에 보여지는 컴포넌트를 모아 놓음
- **컨테이너 폴더**: 데이터 주입 및 처리 역할을 하는 컴포넌트들을 모아 놓음
- **훅(Hooks) 폴더**: 재사용 가능한 훅들을 모아 놓음

리액트에 **Hooks**가 도입되면서, 컨테이너 컴포넌트 대신 훅 폴더를 사용하는 경우도 많아졌습니다. 또한, 다양한 공용 함수나 유틸리티 파일들도 폴더에 모아 관리합니다. 그러나 이 구조가 명확하지 않으면, 프로젝트가 커질수록 복잡도가 증가하고, 파일들이 폴더에 무분별하게 쌓이는 문제가 발생합니다.

---

## 3. FSD(Folder Slice Design) 아키텍처 소개

이 문제를 해결하기 위해, FSD라는 아키텍처를 사용할 수 있습니다. FSD는 프로젝트의 폴더 구조를 **레이어, 슬라이스, 세그먼트**로 나눕니다. 각 단계는 최대한 3단계로 제한되어, 깊고 복잡한 폴더 구조를 피할 수 있습니다.

### FSD의 주요 개념

- **레이어**: 애플리케이션의 큰 부분들을 나누는 기본 폴더. 예를 들어, 앱, 프로세스, 페이지, 위젯, 피처, 엔티티, 쉐어드 등 7가지 레이어가 있습니다.
- **슬라이스(Slice)**: 도메인 주도 설계와 유사한 개념으로, 서로 다른 기능들을 나누는 방식입니다. 예를 들어, `유저 정보`, `게시글`, `댓글` 등을 각각의 슬라이스로 나눌 수 있습니다.
- **세그먼트(Segment)**: 슬라이스 내에서 더 작은 단위로 나누는 것. UI, 모델, API로 나누어 각 역할에 맞는 파일들을 그룹화합니다.

---

## 4. FSD 레이어 구조

FSD에서 폴더 구조를 설정할 때는 아래와 같은 레이어 구조를 따릅니다:

1. **App**: 애플리케이션 전체의 설정을 담당하는 부분입니다. 브라우저 라우터, 리액트 쿼리, 리덕스 프로바이더 등의 전역 설정 파일이 여기에 포함됩니다.
2. **Page**: 라우터에 따라 페이지를 나누는 방식입니다. 예를 들어, 리액트 라우터나 넥스트 라우터를 사용하여 각 페이지를 폴더로 구분합니다.
3. **Shared**: 여러 컴포넌트나 페이지에서 공통적으로 사용되는 유틸리티, 훅, 타입 등을 모아 놓습니다. 이를 통해 코드 재사용성을 높일 수 있습니다.
4. **Entity**: 애플리케이션의 핵심 데이터 구조를 정의하는 폴더입니다. 예를 들어, 유저 정보나 게시글 같은 엔티티 데이터를 관리합니다.
5. **Widget**: 작은 UI 단위 또는 레이아웃을 정의하는 폴더입니다. 여러 피처들을 묶어 위젯으로 관리합니다.

6. **Feature**: 어떤 동작을 하는 기능들을 관리하는 폴더입니다. 예를 들어, '북마크 하다', '포크 하다'와 같은 동작들이 여기에 포함됩니다.

---

## 5. 폴더 구조를 설계할 때의 기준

폴더 구조를 명확하게 설계할 때 가장 중요한 점은 **파일 간 임포트 관계**입니다. FSD에서는 다음과 같은 원칙을 따릅니다:

- **App**은 모든 레이어의 파일을 임포트할 수 있지만, 반대로는 불가능합니다.
- **Page**는 **Feature**, **Entity**, **Shared**의 파일을 임포트할 수 있습니다.
- **Feature**는 **Entity**와 **Shared**의 파일을 임포트할 수 있습니다.
- **Entity**와 **Shared**는 가장 낮은 계층에 위치하며, 서로 간의 임포트만 허용됩니다.

이러한 계층 구조를 통해 프로젝트가 커져도 관리가 용이해지며, 유지보수하기 쉬운 폴더 구조를 가질 수 있습니다.

---

## 6. 인덱스 파일의 활용

폴더 안에 있는 여러 파일들을 외부에서 임포트할 때, 인덱스 파일을 사용하여 관리합니다. 예를 들어, `컴포넌트 폴더`에서 특정 컴포넌트를 익스포트할 때, `index.ts` 파일을 통해 원하는 컴포넌트들만 노출시킵니다. 이를 통해 **캡슐화**가 가능하며, 외부에서 불필요한 파일에 접근하는 것을 방지할 수 있습니다.

```typescript
// index.ts
export { default as Button } from "./Button";
export { default as Modal } from "./Modal";
```

## 7. FSD의 장단점

### 장점

- 폴더 구조가 명확해져, 대형 프로젝트에서 관리가 수월해집니다.
- 파일 간의 임포트 관계가 체계적으로 정리되며, 유지보수와 확장이 용이합니다.
- UI와 로직, 데이터 처리를 분리하여 모듈화된 코드베이스를 유지할 수 있습니다.

### 단점

- 프로젝트가 작은 경우, 오히려 불필요한 폴더 구조로 인해 복잡도가 증가할 수 있습니다.
- 팀 내에서 FSD 구조를 이해하고 지키는 규칙을 모두가 숙지해야 합니다. 그렇지 않으면 규칙이 깨질 수 있습니다.

---

## 8. 결론

FSD 아키텍처는 프로젝트의 폴더 구조를 체계적이고 명확하게 관리하기 위한 훌륭한 방법입니다. 하지만 모든 프로젝트에 적용할 필요는 없으며, **규모가 큰 프로젝트에 적합**합니다. 폴더 구조가 복잡해져서 유지보수가 어려워질 때 FSD를 도입하는 것을 추천드립니다.
